
#
# Test of rename table
#

--source include/count_sessions.inc

--disable_warnings
drop table if exists t0,t1,t2,t3,t4;
# Clear up from other tests (to ensure that SHOW TABLES below is right)
drop table if exists t0,t5,t6,t7,t8,t9,t1_1,t1_2,t9_1,t9_2;
drop table if exists _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl, _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410, child_table, child_table_old, child_table_new;
drop table if exists _vt_vrp_6ace8bcef73211ea87e9f875a4d24e90_20200915120410_, _vt_hld_6ace8bcef73211ea87e9f875a4d24e90_20200915120410_;
drop table if exists parent_table, parent_table_old, parent_table_new;
--enable_warnings

SET FOREIGN_KEY_CHECKS=1;

CREATE TABLE parent_table (
  id INT NOT NULL,
  PRIMARY KEY (id)
);
CREATE TABLE child_table (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id),
  CONSTRAINT `child_parent_fk` FOREIGN KEY (parent_id) REFERENCES parent_table(id) ON DELETE NO ACTION
);
insert into parent_table values (1), (2);
insert into child_table values (10, 1);
insert into child_table values (11, 1);
insert into child_table values (12, 2);
insert into child_table values (13, 2);

CREATE TABLE _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id),
  CONSTRAINT `vrepl_child_parent_fk` FOREIGN KEY (parent_id) REFERENCES parent_table(id) ON DELETE NO ACTION
);
insert into _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl select * from child_table;

CREATE TABLE _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410 (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id),
  CONSTRAINT `hold_child_parent_fk` FOREIGN KEY (parent_id) REFERENCES parent_table(id) ON DELETE NO ACTION
);
insert into _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410 select * from child_table;

CREATE TABLE _vt_hld_6ace8bcef73211ea87e9f875a4d24e90_20200915120410_ (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id),
  CONSTRAINT `hld_child_parent_fk` FOREIGN KEY (parent_id) REFERENCES parent_table(id) ON DELETE NO ACTION
);
insert into _vt_hld_6ace8bcef73211ea87e9f875a4d24e90_20200915120410_ select * from child_table;

CREATE TABLE _vt_vrp_6ace8bcef73211ea87e9f875a4d24e90_20200915120410_ (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id),
  CONSTRAINT `vrp_child_parent_fk` FOREIGN KEY (parent_id) REFERENCES parent_table(id) ON DELETE NO ACTION
);
insert into _vt_vrp_6ace8bcef73211ea87e9f875a4d24e90_20200915120410_ select * from child_table;

# For normal tables this should be invalid, but for internal vitess tables it will work:
--error ER_NO_REFERENCED_ROW_2
insert into child_table values (100, 100);
insert into _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl values (101, 101);
insert into _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410 values (102, 102);
insert into _vt_hld_6ace8bcef73211ea87e9f875a4d24e90_20200915120410_ values (103, 103);
insert into _vt_vrp_6ace8bcef73211ea87e9f875a4d24e90_20200915120410_ values (103, 103);

# This should not work:
--error ER_ROW_IS_REFERENCED_2
delete from parent_table where id=1;
# but if we delete from child_table, the two remaining tables are ignorable:
delete from child_table;
delete from parent_table where id=1;

# This should not work:
--error ER_FK_CANNOT_DROP_PARENT
drop table parent_table;
# but if we drop child_table, then that's fine, and the two other tables do not hold back dropping the parent:
drop table child_table;
drop table parent_table;

# Let's repeat the test, but for CASCADE
drop table _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl;
drop table _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410;
CREATE TABLE parent_table (
  id INT NOT NULL,
  PRIMARY KEY (id)
);
CREATE TABLE child_table (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id),
  CONSTRAINT `child_parent_fk` FOREIGN KEY (parent_id) REFERENCES parent_table(id) ON DELETE CASCADE
);
insert into parent_table values (1), (2);
insert into child_table values (10, 1);
insert into child_table values (11, 1);
insert into child_table values (12, 2);
insert into child_table values (13, 2);

CREATE TABLE _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id),
  CONSTRAINT `vrepl_child_parent_fk` FOREIGN KEY (parent_id) REFERENCES parent_table(id) ON DELETE CASCADE
);
insert into _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl select * from child_table;


CREATE TABLE _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410 (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id),
  CONSTRAINT `hold_child_parent_fk` FOREIGN KEY (parent_id) REFERENCES parent_table(id) ON DELETE CASCADE
);
insert into _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410 select * from child_table;

# For normal tables this should be invalid, but for this table it will work:
--error ER_NO_REFERENCED_ROW_2
insert into child_table values (200, 200);
insert into _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl values (201, 201);
insert into _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410 values (202, 202);

# deleting from parent should only affect child_table, but not the other two tables.
delete from parent_table where id=1;
select * from child_table;
select * from _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl;
select * from _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410;

# This should not work:
--error ER_FK_CANNOT_DROP_PARENT
drop table parent_table;
# but if we drop child_table, then that's fine, and the two other tables do not hold back dropping the parent:
drop table child_table;
drop table parent_table;

# Let's repeat the test, but for SET NULL
drop table _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl;
drop table _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410;
CREATE TABLE parent_table (
  id INT NOT NULL,
  PRIMARY KEY (id)
);
CREATE TABLE child_table (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id),
  CONSTRAINT `child_parent_fk` FOREIGN KEY (parent_id) REFERENCES parent_table(id) ON DELETE SET NULL
);
insert into parent_table values (1), (2);
insert into child_table values (10, 1);
insert into child_table values (11, 1);
insert into child_table values (12, 2);
insert into child_table values (13, 2);

CREATE TABLE _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id),
  CONSTRAINT `vrepl_child_parent_fk` FOREIGN KEY (parent_id) REFERENCES parent_table(id) ON DELETE SET NULL
);
insert into _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl select * from child_table;


CREATE TABLE _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410 (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id),
  CONSTRAINT `hold_child_parent_fk` FOREIGN KEY (parent_id) REFERENCES parent_table(id) ON DELETE SET NULL
);
insert into _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410 select * from child_table;

# For normal tables this should be invalid, but for this table it will work:
--error ER_NO_REFERENCED_ROW_2
insert into child_table values (300, 300);
insert into _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl values (301, 301);
insert into _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410 values (302, 302);

# deleting from parent should only affect child_table, but not the other two tables.
delete from parent_table where id=1;
select * from child_table;
select * from _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl;
select * from _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410;

# This should not work:
--error ER_FK_CANNOT_DROP_PARENT
drop table parent_table;
# but if we drop child_table, then that's fine, and the two other tables do not hold back dropping the parent:
drop table child_table;
drop table parent_table;

# Next, we create a _parent_ table with an ignorable name.
drop table _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl;
drop table _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410;
CREATE TABLE _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl (
  id INT NOT NULL,
  PRIMARY KEY (id)
);
CREATE TABLE child_table (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id),
  CONSTRAINT `child_parent_fk` FOREIGN KEY (parent_id) REFERENCES _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl(id) ON DELETE RESTRICT
);
insert into _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl values (1), (2);
insert into child_table values (10, 1);
insert into child_table values (11, 1);
insert into child_table values (12, 2);
insert into child_table values (13, 2);

# This will work even though there's a RESTRICT:
insert into child_table values (400, 400);
delete from _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl where id=1;
select * from child_table;
# And this will just work:
drop table _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl;
# Cleanup
--disable_warnings
drop table if exists _vt_vrp_6ace8bcef73211ea87e9f875a4d24e90_20200915120410_, _vt_hld_6ace8bcef73211ea87e9f875a4d24e90_20200915120410_;
drop table if exists _84371a37_6153_11eb_9917_f875a4d24e90_20210128122816_vrepl, _vt_HOLD_6ace8bcef73211ea87e9f875a4d24e90_20200915120410, child_table, child_table_old, child_table_new;
drop table if exists parent_table, parent_table_old, parent_table_new;
--enable_warnings
